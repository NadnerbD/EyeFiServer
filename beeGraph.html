<html>
	<head>
		<title>Bee Graph</title>
		<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black" />
		<script type="text/javascript" src="eyefi/pictures.js"></script>
		<script type="text/javascript">
			var graph, ctx;
			var margin = 12;
			var dotRad = 3;
			var exRad = 3;
			var ranges = {
				time: [Number.MAX_VALUE, 0], 
				aT: [Number.MAX_VALUE, 0],
				aL: [Number.MAX_VALUE, 0],
				aH: [Number.MAX_VALUE, 0]
			};
			var selection = null;
			var selectedLine;
			// time mark globals
			var tickLens = [
				60 * 60 * 24, // day
				60 * 60 * 12, // half day
				60 * 60 * 6, // quarter day
				60 * 60, // hour
				60 * 15, // 15 mins
				60, // minute
			];
			var localOffset = 60 * 60 * 4; // GMT-4
			function init() {
				graph = document.getElementById("graph");
				if(graph.getContext) {
					ctx = graph.getContext("2d");
					ctx.fillStyle = "#000000";
					// determine the bounds of the graph
					for(var i = 0; i < pictures.length; i++) {
						var pic = pictures[i];
						console.log(new Date(pic.time * 1000));
						for(var name in ranges) {
							if(pic[name] < ranges[name][0])
								ranges[name][0] = pic[name];
							if(pic[name] > ranges[name][1])
								ranges[name][1] = pic[name];
						}
					}
					console.log("min/max Temp: " + ranges.aT + 
							" Humidity: " + ranges.aH +
							" Light: " + ranges.aL +
							" Time: " + ranges.time);

					// adjust the time range to start 12 hours from the last picture
					//ranges.time[0] = ranges.time[1] - 60 * 60 * 12;
					//drawAll();

					resize();
				}
				graph.addEventListener("mousedown", startDrag);
				graph.addEventListener("mousemove", hoverHandle);
				graph.addEventListener("mousewheel", wheel);
				window.addEventListener("resize", resize);
				// iOS event handlers
				graph.addEventListener("touchstart", touchStart);
				graph.addEventListener("touchmove", touchMove);
				graph.addEventListener("touchend", touchEnd);
				graph.addEventListener("touchcancel", touchCancel);
			}
			function touchStart(event) {
				event.preventDefault();
				lastTouches = [];
				for(var i = 0; i < event.touches.length; i++)
					lastTouches[i] = event.touches[i].pageX;
			}
			function touchMove(event) {
				event.preventDefault(); // prevents iOS drag scrolling
				if(event.touches.length == 1) {
					// we have one touch: do a drag
					var diff = event.touches[0].pageX - lastTouches[0];
					var ofs = -deltaXToDeltaTime(diff);
					// we adjust the time ranges that the graph is drawn between to affect scrolling
					ranges.time[0] += ofs;
					ranges.time[1] += ofs;
				}else if(event.touches.length == 2 && lastTouches.length == 2) {
					// we have two touches: drag-scale (ALGEBRA TO THE RESCUE)
					var A = XToTime(lastTouches[0]);
					var A2 = XToTime(event.touches[0].pageX);
					var B = XToTime(lastTouches[1]);
					var B2 = XToTime(event.touches[1].pageX);
					var scale = (B2 - A2) / (B - A);
					var offset = A2 - A * scale;
					ranges.time[0] = (ranges.time[0] - offset) / scale;
					ranges.time[1] = (ranges.time[1] - offset) / scale;
				}
				lastTouches = [];
				for(var i = 0; i < event.touches.length; i++)
					lastTouches[i] = event.touches[i].pageX;
				drawAll();
			}
			function touchEnd(event) {
			}
			function touchCancel(event) {
			}
			function resize(event) {
				graph.width = window.innerWidth;
				graph.height = window.innerHeight;
				drawAll();
			}
			function wheel(event) {
				event.preventDefault();
				var center = XToTime(event.offsetX);
				if(event.wheelDelta < 0) {
					// zoom out
					ranges.time[0] -= center - ranges.time[0];
					ranges.time[1] += ranges.time[1] - center;
				}else{
					// zoom in
					ranges.time[0] += (center - ranges.time[0]) / 2;
					ranges.time[1] -= (ranges.time[1] - center) / 2;
				}
				drawAll();
			}
			function drawAll() {
				setupGraph(); // draws the borders and gridlines
				drawLines(); // draws the data elements
				drawSelectBox(); // draws the hovertext box
			}
			function drawLines() {
				graphLine("aH", "#00FFFF"); // Humidity, Cyan
				graphLine("aL", "#FFFF00"); // Light, Yellow
				graphLine("aT", "#FF0000"); // Temp, Red
			}
			function drawSelectBox() {
				// selection text
				if(selection) {
					ctx.font = "12px sans-serif";
					var dateString = new Date(selection.time * 1000).toString().split(' ').slice(0, 5).join(' ');
					var textWidth = ctx.measureText(dateString).width;
					var x = timeToX(selection.time) - textWidth / 2;
					var y = dataToY(selection, selectedLine);
					if(y > graph.height / 2)
						y -= 24;
					else
						y += 24;
					ctx.fillStyle = "#FFFFFF";
					ctx.fillRect(x - 3, y - 13, textWidth + 6, 30);
					ctx.fillStyle = "#000000";
					ctx.fillRect(x - 2, y - 12, textWidth + 4, 28);
					var dataNames = {
						aL: ["Light", ""],
						aH: ["Humidity", "%"],
						aT: ["Temperature", "\u00B0F"]
					}
					ctx.fillStyle = "#FFFFFF";
					ctx.fillText(dateString, x, y);
					ctx.fillText(
						dataNames[selectedLine][0] + ": " +
						selection[selectedLine] +
						dataNames[selectedLine][1],
					x, y + 12);
				}
			}
			function setupGraph() {
				// clear the canvas
				ctx.fillStyle = "#000000";
				ctx.fillRect(0, 0, graph.width, graph.height);

				ctx.lineWidth = 2;

				ctx.strokeStyle = "#FFFFFF";

				// vertical axis
				ctx.beginPath();
				ctx.moveTo(margin, graph.height - margin);
				ctx.lineTo(margin, margin);
				ctx.stroke();
				ctx.closePath();

				// horizontal axis
				ctx.beginPath();	
				ctx.moveTo(margin, graph.height - margin);
				ctx.lineTo(graph.width - margin, graph.height - margin);
				ctx.stroke();
				ctx.closePath();

				// time markings
				drawTicks(tickLens[0], [1, 3], 0);
				for(var i = 1; deltaTimeToDeltaX(tickLens[i]) > 50 && i < tickLens.length; i++) {
					drawTicks(tickLens[i], [4, 5], tickLens[i - 1]);
				}
			}
			function drawTicks(tickLen, dateSlice, skip) {
				var markTime = ranges.time[0] - (ranges.time[0] % tickLen) + localOffset;
				while(markTime > ranges.time[0])
					markTime -= tickLen;
				markTime += tickLen;
				for(; markTime < ranges.time[1]; markTime += tickLen) {
					if((markTime - localOffset) % skip == 0)
						continue;
					var markX = timeToX(markTime);
					ctx.strokeStyle = "#FFFFFF";
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(markX, graph.height - margin);
					ctx.lineTo(markX, graph.height);
					ctx.stroke();
					ctx.closePath();
					ctx.strokeStyle = "#888888";
					ctx.lineWidth = 1;
					ctx.beginPath();
					ctx.moveTo(markX, margin);
					ctx.lineTo(markX, graph.height - margin);
					ctx.stroke();
					ctx.closePath();
					ctx.fillStyle = "#FFFFFF";
					ctx.font = "10px sans-serif";
					var label = new Date(markTime * 1000).toString()
						.split(' ').slice(dateSlice[0], dateSlice[1]).join(' ');
					ctx.fillText(label, markX + 2, graph.height - 2);
				}
			}
			function graphLine(name, color) {
				ctx.strokeStyle = color;
				ctx.lineWidth = 2;
				ctx.beginPath()
				var lastTime = 0;
				for(var i = 0; i < pictures.length; i++) {
					var pic = pictures[i];
					x = timeToX(pic.time);
					y = dataToY(pic, name);
					// we don't connect the line if the samples are more than an hour apart
					if(i == 0 || (pic.time - lastTime > 60 * 60))
						ctx.moveTo(x, y);
					else
						ctx.lineTo(x, y);
					lastTime = pic.time;
				}
				ctx.stroke();
				ctx.closePath();
				for(var i = 0; i < pictures.length; i++) {
					var pic = pictures[i];
					var expand = 0;
					if(pic == selection && name == selectedLine)
						expand = exRad;
					x = timeToX(pic.time);
					y = dataToY(pic, name);
					ctx.fillStyle = "#000000";
					ctx.beginPath();
					ctx.arc(x, y, dotRad + expand, 0, Math.PI * 2);
					ctx.fill();
					ctx.closePath();
					ctx.fillStyle = color;
					ctx.beginPath();
					ctx.arc(x, y, dotRad - 1 + expand, 0, Math.PI * 2);
					ctx.fill();
					ctx.closePath();
				}
			}
			function scale(value, inRange, outRange) {
				var frac = (value - inRange[0]) / (inRange[1] - inRange[0]);
				return frac * (outRange[1] - outRange[0]) + outRange[0];
			}
			function timeToX(time) {
				return scale(time, ranges.time, [margin, graph.width - margin]);
			}
			function dataToY(pic, attr) {
				return scale(pic[attr], ranges[attr], [graph.height - margin, margin]);
			}
			function XToTime(x) {
				return scale(x, [margin, graph.width - margin], ranges.time);
			}
			function deltaXToDeltaTime(diff) {
				return diff / (graph.width - margin * 2) * (ranges.time[1] - ranges.time[0]);
			}
			function deltaTimeToDeltaX(diff) {
				return diff * (graph.width - margin * 2) / (ranges.time[1] - ranges.time[0]);
			}
			function startDrag(event) {
				event.preventDefault(); // prevents browser from doing a selection
				if(selection) {
					document.getElementById("picture").src = "eyefi/" + selection.name;
					return;
				}
				var lastPos = [event.clientX, event.clientY];
				function moveHandle(event) {
					var diff = event.clientX - lastPos[0];
					lastPos = [event.clientX, event.clientY];
					var ofs = -deltaXToDeltaTime(diff);
					// we adjust the time ranges that the graph is drawn between to affect scrolling
					ranges.time[0] += ofs;
					ranges.time[1] += ofs;
					drawAll();
				}
				function upHandle(event) {
					document.removeEventListener("mousemove", moveHandle, false);
					document.removeEventListener("mouseup", upHandle, false);
				}
				document.addEventListener("mousemove", moveHandle);
				document.addEventListener("mouseup", upHandle);
			}
			function hoverHandle(event) {
				for(var i = 0; i < pictures.length; i++) {
					var pic = pictures[i];
					if(Math.abs(timeToX(pic.time) - event.offsetX) < dotRad + exRad) {
						for(var name in pic) {
							if(name == "time" || name == "name")
								continue;
							if(Math.abs(dataToY(pic, name) - event.offsetY) < dotRad + exRad) {
								selection = pic;
								selectedLine = name;
								graph.style.cursor = "pointer";
								drawAll();
								return;
							}
						}
					}
				}
				if(selection != null) {
					selection = null;
					graph.style.cursor = "move";
					drawAll();
				}
			}
		</script>
		<style type="text/css">
			html, body {
				width: 100%;
				height: 100%;
				margin: 0px;
				background-color: black;
			}
			#graph {
				cursor: move;
			}
		</style>
	</head>
	<body onload="init()">
		<canvas width="1000" height="300" id="graph">
			Missing canvas support
		</canvas>
		<br/>
		<img id="picture"/>
	</body>
</html>
